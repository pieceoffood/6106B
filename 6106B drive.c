#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl2,  ,               sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mb_left,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           front_left,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port3,           back_left,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           front_right,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port5,           back_right,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           fb_topleft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           fb_bottomleft, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           fb_topright,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           fb_bottomright, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mb_right,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*!!Code automatically generated by 'ROBOTC' configuration wizard!!

remember to flip the wiring!

62.7 counts for tourque
392 counts for high speed
2 feet in 2935.23 revs */


void motorControl()
{
motor[front_left] = vexRT[Ch3];
motor[back_left] = vexRT[Ch3];
motor[front_right] = vexRT[Ch2];
motor[back_right] = vexRT[Ch2];
}

void motorLiftControl ()
{
	if(vexRT[Btn5U] == 1)
	{
		motor[mb_left] = 80;
		motor[mb_right] = 80;
	}
	else if(vexRT[Btn5D] == 1)
	{
		motor[mb_left] = -80;
		motor[mb_right] = -80;
	}
	else
	{
		motor[mb_left] = 0;
		motor[mb_right] = 0;
	}

}
/*
void motorControlWEncoder ()
{

	if(getMotorEncoder(back_left) == 400)
	{

		resetMotorEncoder(back_left);
		resetMotorEncoder(back_right);
		wait1Msec(2000);
	}
	if(getMotorEncoder(back_left) < 400)
	{
		nMotorEncoder[back_left] = 63;
		nMotorEncoder[back_right] = 63;
	}
}
*/
void fourBarLeft(int powerLeft)
{
	motor[fb_topleft] = powerLeft;
	motor[fb_bottomleft] = powerLeft;
}
void fourBarRight(int powerRight)
{
	motor[fb_topright] = powerRight;
	motor[fb_bottomright] = powerRight;
}
void fourbar()
{
	if (vexRT[Btn6U] == 1)
	{
		fourBarLeft(127);
		fourBarRight(127);
	}
	else if (vexRT[Btn6D] == 1)
	{
		fourBarLeft(-64);
		fourBarRight(-64);
	}
}

task main()
{
	nMotorEncoder(back_left) = 400;
	while(true)
	{
		motorControl();
		motorLiftControl();
//		motorControlWEncoder();
		fourbar();
	}
}
