#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl2,  ,               sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mb_left,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           front_left,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port3,           back_left,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           front_right,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port5,           back_right,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           fb_topleft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           fb_bottomleft, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           fb_topright,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           fb_bottomright, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mb_right,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*!!Code automatically generated by 'ROBOTC' configuration wizard!!

remember to flip the wiring!

62.7 counts for tourque
392 counts for high speed
2 feet in 2935.23 revs */


// -----------------BEGIN Global Variables Configuration-------------------

const int MB_POWER = 80; // power to mobile goal lift
const int FOURBAR_POWER = 64; //power to fourbar
const int FOURBAR_ANTIGRAVITY = 20; //power to fourbar when it is in the "stop" position
const int MB_ANTIGRAVITY=5; //power to mobile goal lift when it is in the "stop" position

// ------------------END Global Variables Configuration----------------------


// ------------------BEGIN Utility Functons---------------

void moveLeftWheels(int power)
{
	motor[front_left] = power;
	motor[back_left] = power;
}

void moveRightWheels(int power)
{
	motor[front_right] = power;
	motor[back_right] = power;
}

void mobileGoalUp()
{
	motor[mb_left] = MB_POWER;
	motor[mb_right] = MB_POWER;
}

void mobileGoalDown()
{
	motor[mb_left] = -MB_POWER;
	motor[mb_right] = -MB_POWER;
}

void mobileGoalStop(){
	motor[mb_left] = MB_ANTIGRAVITY;
	motor[mb_right] = MB_ANTIGRAVITY;
}

void fourBarUp()
{
	motor[fb_topleft] = FOURBAR_POWER;
	motor[fb_bottomleft] = FOURBAR_POWER;
	motor[fb_topright] = FOURBAR_POWER;
	motor[fb_bottomright] = FOURBAR_POWER;
}

void fourBarDown()
{

	motor[fb_topleft] = -FOURBAR_POWER;
	motor[fb_bottomleft] = -FOURBAR_POWER;
	motor[fb_topright] = -FOURBAR_POWER;
	motor[fb_bottomright] = -FOURBAR_POWER;
}

void fourBarStop()
{

	motor[fb_topleft] = FOURBAR_ANTIGRAVITY;
	motor[fb_bottomleft] = FOURBAR_ANTIGRAVITY;
	motor[fb_topright] = FOURBAR_ANTIGRAVITY;
	motor[fb_bottomright] = FOURBAR_ANTIGRAVITY;
}

//----------------END Utility Functions------------


//----------------BEGIN Main Functions-------------

void driverControl(){
	for(;;){
		while (vexRT[Btn6U]) fourBarUp();
		while (vexRT[Btn6D]) fourBarDown();
		fourBarStop();
		while (vexRT[Btn5D]) mobileGoalDown();
		while (vexRT[Btn5U]) mobileGoalUp();
		mobileGoalStop();
		moveLeftWheels(vexRT[Ch3]);
		moveRightWheels(vexRT[Ch2]);
	}
}

//--------------END Main Functions------------------

task main()
{
	driverControl();
}
